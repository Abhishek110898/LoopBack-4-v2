"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthStrategyProvider = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@loopback/core");
const keys_1 = require("../keys");
const keys_2 = require("./keys");
let AuthStrategyProvider = class AuthStrategyProvider {
    constructor(metadata, ctx) {
        this.metadata = metadata;
        this.ctx = ctx;
    }
    async processLocalFactory(verifier) {
        const localFactory = this.ctx.getSync(keys_2.Strategies.Passport.LOCAL_STRATEGY_FACTORY, { optional: true });
        if (!localFactory) {
            throw new Error(`No factory found for ${keys_2.Strategies.Passport.LOCAL_STRATEGY_FACTORY}`);
        }
        return localFactory(this.metadata.options, verifier);
    }
    async processBearerFactory(verifier) {
        const bearerFactory = this.ctx.getSync(keys_2.Strategies.Passport.BEARER_STRATEGY_FACTORY, { optional: true });
        if (!bearerFactory) {
            throw new Error(`No factory found for ${keys_2.Strategies.Passport.BEARER_STRATEGY_FACTORY}`);
        }
        return bearerFactory(this.metadata.options, verifier);
    }
    async processResourceOwnerFactory(verifier) {
        const resourceOwnerFactory = this.ctx.getSync(keys_2.Strategies.Passport.RESOURCE_OWNER_STRATEGY_FACTORY, { optional: true });
        if (!resourceOwnerFactory) {
            throw new Error(`No factory found for ${keys_2.Strategies.Passport.RESOURCE_OWNER_STRATEGY_FACTORY}`);
        }
        return resourceOwnerFactory(this.metadata
            .options, verifier);
    }
    async processGoogleFactory(verifier) {
        const googleFactory = this.ctx.getSync(keys_2.Strategies.Passport.GOOGLE_OAUTH2_STRATEGY_FACTORY, { optional: true });
        if (!googleFactory) {
            throw new Error(`No factory found for ${keys_2.Strategies.Passport.GOOGLE_OAUTH2_STRATEGY_FACTORY}`);
        }
        return googleFactory(this.metadata.options, verifier);
    }
    async processAzureFactory(verifier) {
        const azureFactory = this.ctx.getSync(keys_2.Strategies.Passport.AZURE_AD_STRATEGY_FACTORY, { optional: true });
        if (!azureFactory) {
            throw new Error(`No factory found for ${keys_2.Strategies.Passport.AZURE_AD_STRATEGY_FACTORY}`);
        }
        return azureFactory(this.metadata.options, verifier);
    }
    async processKeycloakFactory(verifier) {
        const keycloakFactory = this.ctx.getSync(keys_2.Strategies.Passport.KEYCLOAK_STRATEGY_FACTORY, { optional: true });
        if (!keycloakFactory) {
            throw new Error(`No factory found for ${keys_2.Strategies.Passport.KEYCLOAK_STRATEGY_FACTORY}`);
        }
        return keycloakFactory(this.metadata.options, verifier);
    }
    async processInstagramFactory(verifier) {
        const instagramFactory = this.ctx.getSync(keys_2.Strategies.Passport.INSTAGRAM_OAUTH2_STRATEGY_FACTORY, { optional: true });
        if (!instagramFactory) {
            throw new Error(`No factory found for ${keys_2.Strategies.Passport.INSTAGRAM_OAUTH2_STRATEGY_FACTORY}`);
        }
        return instagramFactory(this.metadata.options, verifier);
    }
    async processAppleFactory(verifier) {
        const appleFactory = this.ctx.getSync(keys_2.Strategies.Passport.APPLE_OAUTH2_STRATEGY_FACTORY, { optional: true });
        if (!appleFactory) {
            throw new Error(`No factory found for ${keys_2.Strategies.Passport.APPLE_OAUTH2_STRATEGY_FACTORY}`);
        }
        return appleFactory(this.metadata.options, verifier);
    }
    async processFacebookFactory(verifier) {
        const facebookFactory = this.ctx.getSync(keys_2.Strategies.Passport.FACEBOOK_OAUTH2_STRATEGY_FACTORY, { optional: true });
        if (!facebookFactory) {
            throw new Error(`No factory found for ${keys_2.Strategies.Passport.FACEBOOK_OAUTH2_STRATEGY_FACTORY}`);
        }
        return facebookFactory(this.metadata.options, verifier);
    }
    processCognitoFactory(verifier) {
        const cognitoFactory = this.ctx.getSync(keys_2.Strategies.Passport.COGNITO_OAUTH2_STRATEGY_FACTORY, { optional: true });
        if (!cognitoFactory) {
            throw new Error(`No factory found for ${keys_2.Strategies.Passport.COGNITO_OAUTH2_STRATEGY_FACTORY}`);
        }
        return cognitoFactory(this.metadata.options, verifier);
    }
    async processOtpAuthFactory(verifier) {
        const otpFactory = this.ctx.getSync(keys_2.Strategies.Passport.OTP_AUTH_STRATEGY_FACTORY, { optional: true });
        if (!otpFactory) {
            throw new Error(`No factory found for ${keys_2.Strategies.Passport.OTP_AUTH_STRATEGY_FACTORY}`);
        }
        return otpFactory(this.metadata.options, verifier);
    }
    async processAuth0Factory(verifier) {
        const auth0Factory = this.ctx.getSync(keys_2.Strategies.Passport.AUTH0_STRATEGY_FACTORY, { optional: true });
        if (!auth0Factory) {
            throw new Error(`No factory found for ${keys_2.Strategies.Passport.AUTH0_STRATEGY_FACTORY}`);
        }
        // Cast the factory output to `Strategy` type
        return auth0Factory(this.metadata.options, verifier);
    }
    async processSamlFactory(verifier) {
        const samlFactory = this.ctx.getSync(keys_2.Strategies.Passport.SAML_STRATEGY_FACTORY, { optional: true });
        if (!samlFactory) {
            throw new Error(`No factory found for ${keys_2.Strategies.Passport.SAML_STRATEGY_FACTORY}`);
        }
        return samlFactory(this.metadata.options, verifier);
    }
    async value() {
        if (!this.metadata) {
            return undefined;
        }
        //check if custom verifier binding is provided in the metadata
        let verifier;
        if (this.metadata.verifier) {
            verifier = await this.ctx.get(this.metadata.verifier);
        }
        const name = this.metadata.strategy;
        switch (name) {
            case "local" /* STRATEGY.LOCAL */: {
                return this.processLocalFactory(verifier);
            }
            case "bearer" /* STRATEGY.BEARER */: {
                return this.processBearerFactory(verifier);
            }
            case "OAuth2 resource owner grant" /* STRATEGY.OAUTH2_RESOURCE_OWNER_GRANT */: {
                return this.processResourceOwnerFactory(verifier);
            }
            case "Google Oauth 2.0" /* STRATEGY.GOOGLE_OAUTH2 */: {
                return this.processGoogleFactory(verifier);
            }
            case "Azure AD" /* STRATEGY.AZURE_AD */: {
                return this.processAzureFactory(verifier);
            }
            case "keycloak" /* STRATEGY.KEYCLOAK */: {
                return this.processKeycloakFactory(verifier);
            }
            case "Instagram Oauth 2.0" /* STRATEGY.INSTAGRAM_OAUTH2 */: {
                return this.processInstagramFactory(verifier);
            }
            case "Apple Oauth 2.0" /* STRATEGY.APPLE_OAUTH2 */: {
                return this.processAppleFactory(verifier);
            }
            case "Facebook Oauth 2.0" /* STRATEGY.FACEBOOK_OAUTH2 */: {
                return this.processFacebookFactory(verifier);
            }
            case "Cognito Oauth 2.0" /* STRATEGY.COGNITO_OAUTH2 */: {
                return this.processCognitoFactory(verifier);
            }
            case "otp" /* STRATEGY.OTP */: {
                return this.processOtpAuthFactory(verifier);
            }
            case "saml" /* STRATEGY.SAML */: {
                return this.processSamlFactory(verifier);
            }
            case "auth0" /* STRATEGY.AUTH0 */: {
                return this.processAuth0Factory(verifier);
            }
            default:
                return Promise.reject(new Error(`The strategy ${name} is not available.`));
        }
    }
};
exports.AuthStrategyProvider = AuthStrategyProvider;
exports.AuthStrategyProvider = AuthStrategyProvider = tslib_1.__decorate([
    tslib_1.__param(0, (0, core_1.inject)(keys_1.AuthenticationBindings.USER_METADATA)),
    tslib_1.__param(1, core_1.inject.context()),
    tslib_1.__metadata("design:paramtypes", [Object, core_1.Context])
], AuthStrategyProvider);
//# sourceMappingURL=user-auth-strategy.provider.js.map