"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RatelimitDatasourceProvider = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@loopback/core");
const repository_1 = require("@loopback/repository");
const rest_1 = require("@loopback/rest");
const rate_limit_memcached_1 = tslib_1.__importDefault(require("rate-limit-memcached"));
const rate_limit_mongo_1 = tslib_1.__importDefault(require("rate-limit-mongo"));
const rate_limit_redis_1 = tslib_1.__importDefault(require("rate-limit-redis"));
const util_1 = require("util");
const keys_1 = require("../keys");
const decoder = new util_1.TextDecoder('utf-8');
let RatelimitDatasourceProvider = class RatelimitDatasourceProvider {
    constructor(getMetadata, application, config) {
        this.getMetadata = getMetadata;
        this.application = application;
        this.config = config;
    }
    value() {
        return this.action();
    }
    async action() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const metadata = await this.getMetadata();
        // // First check if rate limit options available at method level
        const operationMetadata = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.options) !== null && _a !== void 0 ? _a : {};
        // Create options based on global config and method level config
        const opts = { ...this.config, ...operationMetadata };
        const var1 = 60;
        const var2 = 1000;
        if (((_b = this.config) === null || _b === void 0 ? void 0 : _b.type) === 'MemcachedStore') {
            const expiration = ((_c = opts.windowMs) !== null && _c !== void 0 ? _c : var1 * var2) / var2;
            return new rate_limit_memcached_1.default({ client: (_d = this.config) === null || _d === void 0 ? void 0 : _d.client, expiration });
        }
        if (((_e = this.config) === null || _e === void 0 ? void 0 : _e.type) === 'MongoStore') {
            const expireTimeMs = ((_f = opts.windowMs) !== null && _f !== void 0 ? _f : var1 * var2) / var2;
            return new rate_limit_mongo_1.default({
                uri: (_g = this.config) === null || _g === void 0 ? void 0 : _g.uri,
                collectionName: (_h = this.config) === null || _h === void 0 ? void 0 : _h.collectionName,
                expireTimeMs,
            });
        }
        const redisDS = (await this.application.get(`datasources.${(_j = this.config) === null || _j === void 0 ? void 0 : _j.name}`));
        if (!(redisDS === null || redisDS === void 0 ? void 0 : redisDS.connector)) {
            throw new rest_1.HttpErrors.InternalServerError('Invalid Datasource');
        }
        return new rate_limit_redis_1.default({
            sendCommand: async (...args) => {
                const command = `${args[0]}`;
                args.splice(0, 1);
                let res;
                try {
                    res = await this.executeRedisCommand(redisDS, command, args);
                    if (command.toLocaleLowerCase() === 'script') {
                        res = decoder.decode(res);
                    }
                }
                catch (err) {
                    throw new Error(`Could not execute redis command ${err}`);
                }
                return res;
            },
        });
    }
    // returns promisified execute function
    executeRedisCommand(dataSource, command, args) {
        return new Promise((resolve, reject) => {
            var _a;
            if ((_a = dataSource.connector) === null || _a === void 0 ? void 0 : _a.execute) {
                // eslint-disable-next-line  @typescript-eslint/no-floating-promises
                dataSource.connector.execute(command, args, (err, res) => {
                    if (err) {
                        reject(err);
                    }
                    if (res) {
                        resolve(res);
                    }
                    else {
                        return resolve(undefined);
                    }
                });
            }
        });
    }
};
exports.RatelimitDatasourceProvider = RatelimitDatasourceProvider;
exports.RatelimitDatasourceProvider = RatelimitDatasourceProvider = tslib_1.__decorate([
    tslib_1.__param(0, core_1.inject.getter(keys_1.RateLimitSecurityBindings.METADATA)),
    tslib_1.__param(1, (0, core_1.inject)(core_1.CoreBindings.APPLICATION_INSTANCE)),
    tslib_1.__param(2, (0, core_1.inject)(keys_1.RateLimitSecurityBindings.CONFIG, { optional: true })),
    tslib_1.__metadata("design:paramtypes", [Function, rest_1.RestApplication, Object])
], RatelimitDatasourceProvider);
//# sourceMappingURL=ratelimit-datasource.provider.js.map