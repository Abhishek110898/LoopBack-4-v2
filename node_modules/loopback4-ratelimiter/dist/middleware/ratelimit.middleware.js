"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RatelimitMiddlewareProvider = void 0;
const tslib_1 = require("tslib");
// @SONAR_STOP@
const core_1 = require("@loopback/core");
const repository_1 = require("@loopback/repository");
const rest_1 = require("@loopback/rest");
const RateLimit = tslib_1.__importStar(require("express-rate-limit"));
const keys_1 = require("../keys");
const middleware_enum_1 = require("./middleware.enum");
let RatelimitMiddlewareProvider = class RatelimitMiddlewareProvider {
    constructor(getDatastore, getMetadata, application, config) {
        this.getDatastore = getDatastore;
        this.getMetadata = getMetadata;
        this.application = application;
        this.config = config;
    }
    value() {
        const middleware = async (ctx, next) => {
            await this.action(ctx.request, ctx.response);
            return next();
        };
        return middleware;
    }
    async action(request, response) {
        var _a, _b;
        const enabledByDefault = (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.enabledByDefault) !== null && _b !== void 0 ? _b : true;
        const metadata = await this.getMetadata();
        const dataStore = await this.getDatastore();
        if (metadata && !metadata.enabled) {
            return Promise.resolve();
        }
        // Perform rate limiting now
        const promise = () => new Promise((resolve, reject) => {
            var _a, _b;
            // First check if rate limit options available at method level
            const operationMetadata = metadata ? metadata.options : {};
            // Create options based on global config and method level config
            const opts = { ...this.config, ...operationMetadata };
            if (dataStore) {
                opts.store = dataStore;
            }
            opts.message = new rest_1.HttpErrors.TooManyRequests((_b = (_a = opts.message) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : 'Method rate limit reached !');
            const limiter = RateLimit.default(opts);
            limiter(request, response, (err) => {
                if (err) {
                    reject(err);
                }
                resolve();
            });
        });
        if (enabledByDefault === true) {
            await promise();
            // eslint-disable-next-line  @typescript-eslint/prefer-optional-chain
        }
        else if (enabledByDefault === false && metadata && metadata.enabled) {
            await promise();
        }
        else {
            return Promise.resolve();
        }
    }
};
exports.RatelimitMiddlewareProvider = RatelimitMiddlewareProvider;
exports.RatelimitMiddlewareProvider = RatelimitMiddlewareProvider = tslib_1.__decorate([
    (0, core_1.injectable)((0, rest_1.asMiddleware)({
        group: middleware_enum_1.RatelimitActionMiddlewareGroup.RATELIMIT,
        upstreamGroups: rest_1.RestMiddlewareGroups.PARSE_PARAMS,
        downstreamGroups: [rest_1.RestMiddlewareGroups.INVOKE_METHOD],
    })),
    tslib_1.__param(0, core_1.inject.getter(keys_1.RateLimitSecurityBindings.DATASOURCEPROVIDER)),
    tslib_1.__param(1, core_1.inject.getter(keys_1.RateLimitSecurityBindings.METADATA)),
    tslib_1.__param(2, (0, core_1.inject)(core_1.CoreBindings.APPLICATION_INSTANCE)),
    tslib_1.__param(3, (0, core_1.inject)(keys_1.RateLimitSecurityBindings.CONFIG, {
        optional: true,
    })),
    tslib_1.__metadata("design:paramtypes", [Function, Function, rest_1.RestApplication, Object])
], RatelimitMiddlewareProvider);
// @SONAR_START@
//# sourceMappingURL=ratelimit.middleware.js.map